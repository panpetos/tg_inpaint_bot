# /root/tg_inpaint_bot/bot.py
import os
import io
import json
import time
import base64
import logging
from uuid import uuid4
from typing import Tuple

import aiohttp
from dotenv import load_dotenv
from PIL import Image
from aiogram import Bot, Dispatcher, types
from aiogram.types.message import ContentType
from aiogram.utils import executor
from urllib.parse import quote

# ------------------- –∫–æ–Ω—Ñ–∏–≥ -------------------
load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN", "")
STABILITY_API_KEY = os.getenv("STABILITY_API_KEY", "")
PUBLIC_BASE_URL = os.getenv("PUBLIC_BASE_URL", "https://funfishinggame.store").rstrip("/")
PORT = int(os.getenv("PORT", "8000"))

if not BOT_TOKEN or not STABILITY_API_KEY:
    raise SystemExit("BOT_TOKEN –∏/–∏–ª–∏ STABILITY_API_KEY –Ω–µ –∑–∞–¥–∞–Ω—ã –≤ .env")

# –•—Ä–∞–Ω–∏–ª–∏—â–µ –ø–æ–¥ –¥–æ–º–µ–Ω–æ–º (same-origin –¥–ª—è WebApp)
UPLOAD_DIR = "/var/www/funfishinggame.store/html/uploads"
os.makedirs(UPLOAD_DIR, exist_ok=True)

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
log = logging.getLogger("inpaintbot")

bot = Bot(BOT_TOKEN, parse_mode=None)
dp = Dispatcher(bot)

# –ü–æ—Å–ª–µ–¥–Ω—è—è –∫–∞—Ä—Ç–∏–Ω–∫–∞ –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–∏—Å—Ç–∏)
LAST_IMAGE_URL: dict[int, str] = {}

# ------------------- —É—Ç–∏–ª–∏—Ç—ã -------------------
async def download_bytes(url: str) -> bytes:
    async with aiohttp.ClientSession() as sess:
        async with sess.get(url) as r:
            r.raise_for_status()
            return await r.read()

async def save_tg_file_to_uploads(file_id: str) -> tuple[str, str]:
    """
    –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª –∏–∑ Telegram –∏ –∫–ª–∞–¥—ë–º –µ–≥–æ –≤ /uploads.
    –í–æ–∑–≤—Ä–∞—â–∞–µ–º (local_path, public_url).
    """
    f = await bot.get_file(file_id)
    tg_url = f"https://api.telegram.org/file/bot{BOT_TOKEN}/{f.file_path}"

    ext = os.path.splitext(f.file_path)[1].lower() or ".jpg"
    name = f"{int(time.time())}_{uuid4().hex}{ext}"
    local_path = os.path.join(UPLOAD_DIR, name)

    data = await download_bytes(tg_url)

    # –ü–µ—Ä–µ–∫–æ–¥ webp -> png (–µ—Å–ª–∏ –ø—Ä–∏–ª–µ—Ç–µ–ª–æ webp)
    if ext == ".webp":
        try:
            im = Image.open(io.BytesIO(data)).convert("RGB")
            buf = io.BytesIO()
            im.save(buf, format="PNG")
            data = buf.getvalue()
            name = name.rsplit(".", 1)[0] + ".png"
            local_path = os.path.join(UPLOAD_DIR, name)
        except Exception:
            pass

    with open(local_path, "wb") as out:
        out.write(data)

    public_url = f"{PUBLIC_BASE_URL}/uploads/{name}"
    return local_path, public_url

def _unpack_bitmask_to_L(b64: str, w: int, h: int) -> Image.Image:
    """
    –ò–∑ –∫–æ–º–ø–∞–∫—Ç–Ω–æ–π –±–∏—Ç–æ–≤–æ–π –º–∞—Å–∫–∏ (MSB-first) –¥–µ–ª–∞–µ–º Pillow 'L' (0/255).
    """
    raw = base64.b64decode(b64)
    total = w * h
    out = bytearray(total)
    idx = 0
    for b in raw:
        for bit in range(7, -1, -1):
            if idx >= total:
                break
            out[idx] = 255 if ((b >> bit) & 1) else 0
            idx += 1
        if idx >= total:
            break
    return Image.frombytes("L", (w, h), bytes(out))

def _build_fullsize_mask(nat_w: int, nat_h: int, bbox: Tuple[int, int, int, int], small_mask: Image.Image) -> Image.Image:
    """
    –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –º–∞–ª–µ–Ω—å–∫—É—é –º–∞—Å–∫—É –≤ –ø–æ–ª–Ω–æ—Ä–∞–∑–º–µ—Ä–Ω—É—é 'L' (–Ω–∞—Ç–∏–≤–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è).
    bbox = (x, y, w, h) ‚Äî –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö –ø–∏–∫—Å–µ–ª—è—Ö.
    """
    x, y, w, h = bbox
    mask_full = Image.new("L", (nat_w, nat_h), 0)
    if w > 0 and h > 0:
        m = small_mask.resize((w, h), Image.NEAREST)
        mask_full.paste(m, (x, y))
    return mask_full

async def call_stability_inpaint(image_bytes: bytes, mask_png: bytes, prompt: str) -> bytes:
    """
    –í—ã–∑–æ–≤ Stability Inpaint. –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û —à–ª—ë–º Accept: image/*.
    """
    url = "https://api.stability.ai/v2beta/stable-image/edit/inpaint"
    headers = {
        "Authorization": f"Bearer {STABILITY_API_KEY}",
        "Accept": "image/*",  # <‚Äî —ç—Ç–æ –ª–µ—á–∏—Ç –æ—à–∏–±–∫—É ¬´accept: expected image/*, but received */*¬ª
    }

    form = aiohttp.FormData()
    form.add_field("image", image_bytes, filename="image.png", content_type="image/png")
    form.add_field("mask",  mask_png,   filename="mask.png",  content_type="image/png")
    if (prompt or "").strip():
        form.add_field("prompt", prompt.strip())
    form.add_field("output_format", "png")

    async with aiohttp.ClientSession() as sess:
        async with sess.post(url, headers=headers, data=form, timeout=180) as resp:
            if resp.status != 200:
                txt = await resp.text()
                raise RuntimeError(f"Stability API error: {resp.status} {txt}")
            return await resp.read()

# ------------------- —Ö–µ–Ω–¥–ª–µ—Ä—ã -------------------
@dp.message_handler(commands=["start"])
async def start_cmd(m: types.Message):
    await m.answer(
        "–ü—Ä–∏–≤–µ—Ç! –ü—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ (–∫–∞–∫ —Ñ–æ—Ç–æ –∏–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç). –Ø –≤–µ—Ä–Ω—É –∫–∞—Ä—Ç–∏–Ω–∫—É —Å –∏–Ω–ø–µ–π–Ω—Ç–æ–º.\n\n"
        "–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∂–º–∏ –∫–Ω–æ–ø–∫—É ¬´üñå –û—Ç–∫—Ä—ã—Ç—å –∫–∏—Å—Ç—å¬ª.",
    )

def webapp_button(url: str) -> types.InlineKeyboardMarkup:
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("üñå –û—Ç–∫—Ä—ã—Ç—å –∫–∏—Å—Ç—å", web_app=types.WebAppInfo(url=url)))
    return kb

@dp.message_handler(content_types=[ContentType.PHOTO, ContentType.DOCUMENT])
async def got_image(m: types.Message):
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ–º —Ñ–æ—Ç–æ/–¥–æ–∫—É–º–µ–Ω—Ç -> —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ /uploads -> –¥–∞—ë–º –∫–Ω–æ–ø–∫—É WebApp.
    """
    if m.content_type == ContentType.PHOTO:
        file_id = m.photo[-1].file_id
    else:
        if not (m.document.mime_type and m.document.mime_type.startswith("image/")):
            await m.reply("–ü—Ä–∏—à–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ –≤–∏–¥–µ —Ñ–æ—Ç–æ –∏–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞.")
            return
        file_id = m.document.file_id

    local_path, public_url = await save_tg_file_to_uploads(file_id)
    LAST_IMAGE_URL[m.chat.id] = public_url
    log.info("Saved: %s -> %s", local_path, public_url)

    # cache-bust –∏ –ø–æ–ª–Ω–æ–µ URL-–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ img
    ver = int(time.time())
    wa_url = f"{PUBLIC_BASE_URL}/index.html?v={ver}&img={quote(public_url, safe='')}"

    await m.answer(
        "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ. –ñ–º–∏ ¬´üñå –û—Ç–∫—Ä—ã—Ç—å –∫–∏—Å—Ç—å¬ª.",
        reply_markup=webapp_button(wa_url)
    )

@dp.message_handler(content_types=ContentType.WEB_APP_DATA)
async def webapp_data(m: types.Message):
    """
    –ü–æ–ª—É—á–∞–µ–º –∏–∑ WebApp –∫–æ–º–ø–∞–∫—Ç–Ω—É—é –º–∞—Å–∫—É, bbox –∏ –∏—Å—Ö–æ–¥–Ω—ã–π img URL,
    —Å–æ–±–∏—Ä–∞–µ–º –ø–æ–ª–Ω–æ—Ä–∞–∑–º–µ—Ä–Ω—É—é –º–∞—Å–∫—É -> Stability -> –æ—Ç–¥–∞—ë–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç.
    """
    try:
        data = json.loads(m.web_app_data.data)
    except Exception:
        await m.reply("–ù–µ —Å–º–æ–≥ –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ WebApp :(")
        return

    img_url = data.get("img") or LAST_IMAGE_URL.get(m.chat.id)
    prompt = (data.get("prompt") or "").strip()
    nat_w = int(data.get("nat_w") or 0)
    nat_h = int(data.get("nat_h") or 0)
    bm_w  = int(data.get("bm_w")  or 0)
    bm_h  = int(data.get("bm_h")  or 0)
    bbox  = data.get("bbox") or [0, 0, 0, 0]
    bitmask_b64 = data.get("bitmask")

    if not img_url or not bitmask_b64 or not nat_w or not nat_h or not bm_w or not bm_h:
        await m.reply("–ü–æ—Ö–æ–∂–µ, –º–∞—Å–∫–∞ –∏–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ –ø—Ä–∏—à–ª–∏. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
        return

    # –º–∞–ª–µ–Ω—å–∫–∞—è –º–∞—Å–∫–∞ -> –ø–æ–ª–Ω–æ—Ä–∞–∑–º–µ—Ä–Ω–∞—è L-–º–∞—Å–∫–∞
    small_mask = _unpack_bitmask_to_L(bitmask_b64, bm_w, bm_h)
    mask_full  = _build_fullsize_mask(nat_w, nat_h, tuple(map(int, bbox)), small_mask)

    bio = io.BytesIO()
    mask_full.save(bio, format="PNG")
    mask_bytes = bio.getvalue()

    status = await m.reply("–ú–∞—Å–∫–∞ –ø–æ–ª—É—á–µ–Ω–∞. –ì–µ–Ω–µ—Ä–∏—Ä—É—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç‚Ä¶")
    try:
        # –µ—Å–ª–∏ –∫–∞—Ä—Ç–∏–Ω–∫–∞ –∏–∑ –Ω–∞—à–µ–≥–æ /uploads ‚Äî —á–∏—Ç–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ (–±—ã—Å—Ç—Ä–µ–µ –∏ –Ω–∞–¥—ë–∂–Ω–µ–µ)
        image_bytes: bytes
        prefix = f"{PUBLIC_BASE_URL}/uploads/"
        if img_url.startswith(prefix):
            name = img_url.split("/uploads/")[-1].split("?")[0]
            local_path = os.path.join(UPLOAD_DIR, name)
            with open(local_path, "rb") as f:
                image_bytes = f.read()
        else:
            image_bytes = await download_bytes(img_url)

        result_png = await call_stability_inpaint(image_bytes, mask_bytes, prompt or "inpaint")
    except Exception as e:
        log.exception("Inpaint failed")
        await status.edit_text(f"–û—à–∏–±–∫–∞: {e}")
        return

    await status.delete()
    await m.reply_photo(types.InputFile(io.BytesIO(result_png), filename="result.png"), caption="–ì–æ—Ç–æ–≤–æ ‚ú®")

# ------------------- –∑–∞–ø—É—Å–∫ -------------------
if __name__ == "__main__":
    log.info("Bot: InpaintBot start")
    executor.start_polling(dp, skip_updates=True)
